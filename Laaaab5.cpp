
#include <iostream>
#define SIZE 30
#define INF 1000
using namespace std;

int main()
{
	int adjacency[SIZE][SIZE] = { {0,8,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
								  {8,0,4,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
								  {0,4,0,6,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
								  {0,0,6,0,2,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
								  {0,0,0,2,0,4,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
								  {0,0,0,0,4,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
								  {4,0,0,0,0,0,0,2,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
								  {0,1,0,0,0,0,2,0,1,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
								  {0,0,4,0,0,0,0,1,0,1,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
								  {0,0,0,7,0,0,0,0,1,0,1,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
								  {0,0,0,0,7,0,0,0,0,1,0,5,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0},
								  {0,0,0,0,0,5,0,0,0,0,5,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0},
								  {0,0,0,0,0,0,3,0,0,0,0,0,0,1,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0},
								  {0,0,0,0,0,0,0,3,0,0,0,0,1,0,1,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0},
								  {0,0,0,0,0,0,0,0,3,0,0,0,0,1,0,3,0,0,0,0,3,0,0,0,0,0,0,0,0,0},
								  {0,0,0,0,0,0,0,0,0,7,0,0,0,0,3,0,6,0,0,0,0,1,0,0,0,0,0,0,0,0},
								  {0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,6,0,1,0,0,0,0,3,0,0,0,0,0,0,0},
								  {0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,1,0,0,0,0,0,0,8,0,0,0,0,0,0},
								  {0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,3,0,0,0,0,4,0,0,0,0,0},
								  {0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,3,0,7,0,0,0,0,1,0,0,0,0},
								  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,7,0,5,0,0,0,0,2,0,0,0},
								  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,5,0,8,0,0,0,0,7,0,0},
								  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,8,0,5,0,0,0,0,3,0},
								  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,5,0,0,0,0,0,0,1},
								  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,3,0,0,0,0},
								  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,3,0,3,0,0,0},
								  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,3,0,4,0,0},
								  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,4,0,7,0},
								  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,7,0,7},
								  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,7,0},   };     
	int mindistance[SIZE];                        // мінімальна відстань
	int visited[SIZE];                            // пройдені вершини
	int min, minindex, temp;
	int begin_index = 0;                          // початкова вершина

	for (int i = 0; i < SIZE; i++)                
	{
		mindistance[i] = INF;                     // ініціалізація відстаней як невідомих
		visited[i] = 1;                           // 1 - непройдена вершина
	}
	mindistance[begin_index] = 0;                 // відстань до початкової вершини
	
	do {
		minindex = INF;
		min = INF;
		for (int i = 0; i < SIZE; i++)
		{ 
			if ((visited[i] == 1) && (mindistance[i] < min))              //перевірка чи вершина пройдена
			{ 
				min = mindistance[i];                                     // переприсвоєння мінімального значення
				minindex = i;
			}
		}
		
		if (minindex != INF)
		{
			for (int i = 0; i < SIZE;  i++)
			{
				if (adjacency[minindex][i] > 0)
				{
					temp = min + adjacency[minindex][i];                  // додаємо знайдену мінімальну відстань до поточної відстані
					if (temp < mindistance[i])
					{
						mindistance[i] = temp;                           // остаточна мінімальна відстань до і-тої вершини
					}
				}
			}
			visited[minindex] = 0;                                       // позначення вершини як пройденої
		}
	} while (minindex < INF);
	

	cout << endl << "\t______________THE_SHORTEST_DISTANCE_TO_THE_VERTICES______________" << endl << endl;
	for (int i = 0; i < SIZE; i++) { 
		if (i == 0)
		{
			cout << "\t\tTo V0-vertice :  " << mindistance[i] << "\n";
			continue;
		}
		if (i == SIZE-1)
		{
			cout << "\t\tTo V*-vertice :  " << mindistance[i] << "\n";
			break;
		}
		cout << "\t\tTo V" << i + 1 << "-vertice :  " << mindistance[i] << "\n";
	}
	

	int vis[SIZE];                                                   // пройдені вершини
	int end = SIZE - 1;                                              // індекс кінцевої вершини
	int prev = 1;                                               
	int weight = mindistance[end];                                   // відстань до кінцевої вершини
	vis[0] = end + 1;                                                // початок - кінцева вершина

	while (end != begin_index)                               
	{
		for (int i = 0; i < SIZE; i++) {                          
			if (adjacency[end][i] != 0)                           // якщо є сумісність - перевірка на знаходження відстані, знайденої раніше
			{
				int temp = weight - adjacency[end][i]; 
				if (temp == mindistance[i])
				{         
					weight = temp;
					end = i; 
					vis[prev] = i + 1;                            // збереження відстані, через яку був перехід у найкоротшому шляху
					prev++;
				}
			}
		}
	}
	
	cout << endl << "\t_______________THE_PATH_OF_THE_SHORTEST_DISTANCE_______________" << endl << endl;
	cout << "    ";
	for (int i = prev - 1; i >= 0; i--) {

		cout << "V" << vis[i] << " => ";
	}
	cout << " The path is finished !";
	cout << endl << endl << endl;
	system("pause");
	return 0;
}

